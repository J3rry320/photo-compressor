#!/usr/bin/env node
(()=>{var e={219:(e,o,t)=>{const i=t(896),n=t(928),r=t(938),a=t(832),{logger:s}=t(484),{compressImage:c}=t(200);let l=0,p=0;function d(e){return/\.(jpg|jpeg|png|gif|webp)$/i.test(e)}async function m(e,o){try{const t=await r.get(e,{responseType:"arraybuffer"}),a=n.basename(e).split("?")[0],d=n.join(o,`${a.split(".")[0]}.webp`),m=Buffer.byteLength(t.data);await c(t.data,d);const g=i.statSync(d).size,u=m-g,y=Math.round(u/m*100);l+=u,p+=1,s.success(`ðŸŽ‰ Optimized and compressed: ${e} -> ${d} | Original: ${Math.round(m/1024)} KB Optimized: ${Math.round(g/1024)} KB Saved: ${Math.round(u/1024)} KB (${y}%)`)}catch(o){s.error(`âŒ Error optimizing ${e}: ${o.message}`)}}e.exports={fetchAndOptimizeCloudImages:async function(e,o="../optimized"){const t=Date.now();i.existsSync(o)||i.mkdirSync(o);try{const t=await r.get(e);Array.isArray(e)?(s.info(`You provided an array of images containing ${e.length} images. Processing in parallel...`),await Promise.all(e.map((e=>{if(d(e))return m(e,o)}))),s.info("Batch processing completed.")):"string"==typeof t.data&&d(e)?(s.info("Detected a single image."),await m(e,o)):s.error("Invalid URL: Must point to a single image or a directory listing of image URLs.")}catch(e){s.error(`Error processing cloud images: ${e.message}`)}const n=((Date.now()-t)/1e3).toFixed(2),c=`${l} bytes (${Math.round(l/1024)} KB / ${Math.round(l/1024/1024)} MB)`,p=`${n} seconds`,g=Array.isArray(e)?`${e.length} files`:"1 file";s.art(`Optimization Summary:\n\nTotal savings: ${a.yellowBright.bold(c)}\n\nTime taken: ${a.cyanBright.bold(p)}\n\nFiles processed: ${a.greenBright.bold(g)}`)},processImage:m,isValidImageURL:d}},609:(e,o,t)=>{const i=t(896),n=t(928),r=t(832),{logger:a}=t(484),{compressImage:s}=t(200);let c=0;e.exports={scanAndOptimize:async function(e,o="../optimized"){const t=Date.now();if(!i.existsSync(e))return void a.error(`Directory not found: ${e}`);const l=i.readdirSync(e).filter((e=>null!=e&&[".jpg",".jpeg",".png",".gif",".webp"].includes(n.extname(e).toLowerCase())));if(!l.length)return void a.warning("No valid image files found for optimization.");i.existsSync(o)||i.mkdirSync(o),a.info(`Found ${l.length} images. Processing in parallel...`),await Promise.all(l.map((async t=>{const r=n.join(e,t);let l=n.join(o,`${n.basename(t,n.extname(t))}.webp`);i.existsSync(l)&&(l=n.join(o,`${n.basename(t,n.extname(t))}_compressed.webp`));try{const e=i.statSync(r).size;await s(r,l);const o=i.statSync(l).size,n=e-o,p=Math.round(n/e*100);c+=n,a.success(`ðŸŽ‰ Optimized and compressed: ${t} -> ${l} | Original: ${Math.round(e/1024)} KB Optimized: ${Math.round(o/1024)} KB Saved: ${Math.round(n/1024)} KB (${p}%)`)}catch(e){a.error(`âŒ Error optimizing ${t}: ${e.message}`)}})));const p=((Date.now()-t)/1e3).toFixed(2);a.success("\nBatch optimization completed! ðŸš€\n");const d=`${c} bytes (${Math.round(c/1024)} KB / ${Math.round(c/1024/1024)} MB)`,m=`${p} seconds`,g=`${l.length} files`;a.art(`Optimization Summary:\n\nTotal savings: ${r.yellowBright.bold(d)}\n\nTime taken: ${r.cyanBright.bold(m)}\n\nFiles processed: ${r.greenBright.bold(g)}`)}}},697:(e,o,t)=>{const i=t(679),n=t(832),r=["Standard","Slant","Doom","Big","Larry 3D","3D-ASCII","Cyberlarge","Banner","Block","Bubble","Bulbhead","Digital","Ivrit","Lean","Ogre","Pawp","Rectangles","Stop","Small","Shadow","Speed","Train","Whimsy"],a=[n.red,n.green,n.yellow,n.blue,n.magenta,n.cyan,n.white];e.exports={randomFigletText:function(e){const o=r[Math.floor(Math.random()*r.length)];return`\n ${(0,a[Math.floor(Math.random()*a.length)])(i.textSync(e,{font:o,horizontalLayout:"full"}))} \n`}}},200:(e,o,t)=>{const i=t(288);e.exports={compressImage:async function(e,o){return await i(e).webp({quality:85,effort:6,nearLossless:!0}).toFile(o,{withoutMetadata:!0})}}},484:(e,o,t)=>{const i=t(832),n=e=>`\n${e}\n`,r={info:e=>{console.log(n(i.cyan.underline(e)))},success:e=>{console.log(n(i.green.bold(e)))},warning:e=>{console.log(n(i.yellow.underline(e)))},error:e=>{console.log(n(i.red.bold(e)))},art:(e,o)=>{let t=e;for(const e in o)t=t.split(e).join(o[e]);console.log(t)}};e.exports={logger:r}},938:e=>{"use strict";e.exports=require("axios")},832:e=>{"use strict";e.exports=require("cli-color")},858:e=>{"use strict";e.exports=require("commander")},679:e=>{"use strict";e.exports=require("figlet")},288:e=>{"use strict";e.exports=require("sharp")},896:e=>{"use strict";e.exports=require("fs")},928:e=>{"use strict";e.exports=require("path")}},o={};function t(i){var n=o[i];if(void 0!==n)return n.exports;var r=o[i]={exports:{}};return e[i](r,r.exports,t),r.exports}const{Command:i}=t(858),{scanAndOptimize:n}=t(609),{fetchAndOptimizeCloudImages:r}=t(219),{logger:a}=t(484),{randomFigletText:s}=t(697);console.log(s("photo-compressor"));const c=new i;c.name("photo-compressor").description("Optimize and compress images locally or from the cloud.").version("1.0.0"),c.command("local").description("Optimize images in a local directory").option("-d, --dir <path>","Directory to scan for images").option("-o, --output <path>","Output directory for optimized images","./optimized").action((async e=>{a.info("âœ¨ Starting local optimization..."),await n(e.dir,e.output),a.info("âœ… Local optimization completed.")})),c.command("cloud").description("Optimize images from a URL or a directory URL").option("-u, --url <url>","URL of the image or an array of images to compress").option("-o, --output <path>","Output directory for optimized images","./optimized").action((async e=>{a.info("âœ¨ Starting cloud optimization..."),await r(e.url,e.output),a.info("âœ… Cloud optimization completed.")})),c.parse(process.argv),module.exports={}})();